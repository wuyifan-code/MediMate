<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Midnight Glitch: Astro Run V3</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: 'VT323', monospace;
            color: #fff;
            touch-action: none; 
            -webkit-user-select: none;
            user-select: none;
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 900px;
            aspect-ratio: 16/9;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            overflow: hidden;
            border: 2px solid #333;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
            background: #050011;
        }

        /* UI */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            text-shadow: 2px 2px 0px #ff00ff;
            font-weight: bold;
        }

        .energy-bar-container {
            margin-top: 10px;
        }

        .energy-bar {
            width: 120px;
            height: 10px;
            background: #222;
            border: 2px solid #fff;
        }

        .energy-fill {
            width: 100%;
            height: 100%;
            background: #00f0ff;
            box-shadow: 0 0 8px #00f0ff;
            transition: width 0.1s;
        }

        /* Screens */
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 50;
            pointer-events: auto;
        }

        h1 {
            font-size: 48px;
            color: #00f0ff;
            text-shadow: 3px 3px 0px #ff00ff;
            margin: 0 0 10px 0;
            letter-spacing: 2px;
        }
        
        h2 {
            font-size: 24px;
            color: #ffcc00;
            margin-bottom: 30px;
            font-weight: normal;
        }

        .btn-start {
            padding: 12px 35px;
            font-size: 24px;
            background: transparent;
            color: #fff;
            border: 2px solid #ff00ff;
            font-family: 'VT323', monospace;
            cursor: pointer;
            box-shadow: 0 0 10px #ff00ff;
            transition: all 0.2s;
        }

        .btn-start:active {
            background: #ff00ff;
            color: #000;
            transform: scale(0.95);
        }

        .hidden { display: none !important; }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 180px;
            pointer-events: none;
            z-index: 40;
            display: flex;
            justify-content: space-between;
            padding: 0 30px;
            box-sizing: border-box;
        }

        .control-pad {
            display: flex;
            gap: 15px;
            align-items: flex-end;
            pointer-events: auto;
        }

        .btn-game {
            width: 65px;
            height: 65px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            backdrop-filter: blur(2px);
            user-select: none;
        }

        .btn-game:active, .btn-game.active {
            background: rgba(0, 240, 255, 0.3);
            border-color: #00f0ff;
            transform: scale(0.92);
        }

        .btn-rect { border-radius: 12px; width: 75px; height: 60px; font-size: 30px; }

        .action-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 12px;
        }

        #btn-jump { grid-column: 2; grid-row: 2; border-color: #ffe600; color: #ffe600; }
        #btn-shoot { grid-column: 1; grid-row: 2; border-color: #ff00ff; color: #ff00ff; width: 55px; height: 55px; align-self: center; justify-self: end; }
        #btn-dash { grid-column: 2; grid-row: 1; border-color: #00f0ff; color: #00f0ff; font-size: 16px; height: 50px; margin-bottom: -5px;}

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(18,16,16,0) 50%, rgba(0,0,0,0.1) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 20;
            opacity: 0.6;
        }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        
        <div id="ui-layer">
            <div class="hud-top">
                <div id="score">SCORE: 000000</div>
                <div id="health">HP: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            </div>
            <div class="energy-bar-container">
                <div class="energy-bar"><div id="energy-fill" class="energy-fill"></div></div>
                <div style="font-size: 14px; color: #00f0ff; text-shadow: 1px 1px #000; margin-top: 4px;">PHASE DASH</div>
            </div>
        </div>

        <div id="mobile-controls">
            <div class="control-pad">
                <div class="btn-game btn-rect" id="btn-left">‚Üê</div>
                <div class="btn-game btn-rect" id="btn-right">‚Üí</div>
            </div>
            <div class="control-pad action-group">
                <div class="btn-game" id="btn-dash">DASH</div>
                <div class="btn-game" id="btn-shoot">ATK</div>
                <div class="btn-game" id="btn-jump">JUMP</div>
            </div>
        </div>

        <div id="start-screen">
            <h1>Midnight Glitch</h1>
            <h2>V3.0 - NEW ENEMIES</h2>
            <button class="btn-start" onclick="window.startGame()">START GAME</button>
        </div>

        <div id="game-over-screen" class="hidden">
            <h1 style="color: #ff0000;">GAME OVER</h1>
            <p id="final-score" style="font-size: 24px; margin-bottom: 20px;">SCORE: 0</p>
            <button class="btn-start" onclick="window.resetGame()">RETRY</button>
        </div>
    </div>

<script>
(function() {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    function resize() {
        canvas.width = 800;
        canvas.height = 450;
    }
    resize();

    const uiScore = document.getElementById('score');
    const uiHealth = document.getElementById('health');
    const uiEnergy = document.getElementById('energy-fill');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreEl = document.getElementById('final-score');

    let gameState = 'MENU';
    let score = 0;
    let frameCount = 0;
    let cameraX = 0;
    
    const keys = { left: false, right: false, up: false, shoot: false, dash: false, upPressed: false };

    // Colors
    const C = { bg: '#050011', pink: '#ff00ff', cyan: '#00f0ff', yellow: '#ffe600', white: '#ffffff', danger: '#ff3333', purple: '#aa00ff' };

    // --- CLASSES ---

    class Player {
        constructor() {
            this.w = 28;
            this.h = 44;
            this.x = 100;
            this.y = 200;
            this.vx = 0;
            this.vy = 0;
            this.maxSpeed = 3.2; 
            this.accel = 0.3;
            this.friction = 0.85;
            this.jumpForce = -10.5;
            this.gravity = 0.55;
            
            this.grounded = false;
            this.facingRight = true;
            this.hp = 3;
            
            this.canDash = true;
            this.isDashing = false;
            this.dashTimer = 0;
            this.dashCooldown = 0;
            this.invincible = 0;
            
            this.jumpCount = 0;
            this.maxJumps = 2;
            this.shootCooldown = 0;
        }

        update() {
            // Improved movement controls with better acceleration
            if (keys.right) { this.vx += this.accel * 1.2; this.facingRight = true; } 
            else if (keys.left) { this.vx -= this.accel * 1.2; this.facingRight = false; } 
            else { this.vx *= this.friction * 0.95; }

            if(this.vx > this.maxSpeed) this.vx = this.maxSpeed;
            if(this.vx < -this.maxSpeed) this.vx = -this.maxSpeed;
            if(Math.abs(this.vx) < 0.1) this.vx = 0;

            // Improved jump with better responsiveness
            if (keys.up) {
                if (!keys.upPressed && this.jumpCount < this.maxJumps) {
                    this.vy = this.jumpForce * 1.1;
                    this.jumpCount++;
                    this.grounded = false;
                    createParticles(this.x + this.w/2, this.y + this.h, 8, C.cyan, 'STAR');
                    keys.upPressed = true;
                }
            } else {
                keys.upPressed = false;
            }

            if (keys.dash && this.dashCooldown <= 0) {
                this.isDashing = true;
                this.dashTimer = 12;
                this.dashCooldown = 120;
                this.vx = this.facingRight ? 12 : -12;
                this.vy = 0;
                createShockwave(this.x + this.w/2, this.y + this.h/2);
            }

            if (this.isDashing) {
                this.dashTimer--;
                this.vy = 0;
                if (this.dashTimer <= 0) {
                    this.isDashing = false;
                    this.vx *= 0.3; 
                }
                if (frameCount % 3 === 0) createParticles(this.x, this.y, 1, C.pink);
            } else {
                this.vy += this.gravity;
                this.y += this.vy;
                this.x += this.vx;
            }

            if (this.shootCooldown > 0) this.shootCooldown--;
            if (keys.shoot && this.shootCooldown <= 0) {
                bullets.push(new Bullet(this.x + (this.facingRight?30:-10), this.y + 18, this.facingRight?10:-10, true));
                this.shootCooldown = 18;
            }

            if (this.dashCooldown > 0) this.dashCooldown--;
            if (this.invincible > 0) this.invincible--;

            if (this.y > canvas.height + 100) this.takeDamage(100);
            
            uiEnergy.style.width = Math.max(0, (120 - this.dashCooldown)/1.2) + '%';
        }

        draw() {
            if (this.invincible > 0 && Math.floor(frameCount/5)%2===0) return;
            let dx = Math.floor(this.x - cameraX);
            let dy = Math.floor(this.y);
            ctx.fillStyle = this.isDashing ? C.pink : C.white;
            ctx.fillRect(dx + 4, dy, 20, 18);
            ctx.fillStyle = C.cyan; 
            ctx.fillRect(dx + (this.facingRight?14:6), dy + 4, 10, 8);
            ctx.fillStyle = '#ccc'; 
            ctx.fillRect(dx + 6, dy + 18, 16, 14);
            ctx.fillStyle = '#999';
            ctx.fillRect(dx + (this.facingRight?0:22), dy + 20, 6, 10);
            ctx.fillStyle = '#fff'; 
            let legOffset = 0;
            if(Math.abs(this.vx) > 0.5 && !this.isDashing && this.grounded) {
                legOffset = Math.sin(frameCount * 0.5) * 3;
            }
            ctx.fillRect(dx + 6, dy + 32 + legOffset, 6, 12);
            ctx.fillRect(dx + 16, dy + 32 - legOffset, 6, 12);
        }

        takeDamage(amt) {
            if (this.isDashing || this.invincible > 0) return;
            this.hp -= amt;
            this.invincible = 90;
            createParticles(this.x, this.y, 15, C.danger);
            updateHealthUI();
            if (this.hp <= 0) endGame();
        }
    }

    class Bullet {
        constructor(x, y, vx, isPlayer) {
            this.x = x; this.y = y; this.vx = vx; this.isPlayer = isPlayer; this.active = true;
            this.h = 4; this.w = 8;
            this.trail = [];
            this.maxTrailLength = 5;
            if(!isPlayer) { this.h = 6; this.w = 6; }
        }
        update() {
            // Add trail point
            this.trail.push({x: this.x, y: this.y});
            if(this.trail.length > this.maxTrailLength) this.trail.shift();
            
            this.x += this.vx;
            if (Math.abs(this.x - cameraX) > 600) this.active = false;
        }
        draw() {
            let dx = this.x - cameraX;
            
            // Draw trail
            if(this.trail.length > 1) {
                ctx.save();
                ctx.globalAlpha = 0.6;
                for(let i=0; i<this.trail.length-1; i++) {
                    let t = this.trail[i];
                    let tdx = t.x - cameraX;
                    let alpha = (i+1)/this.trail.length;
                    ctx.globalAlpha = alpha * 0.6;
                    ctx.fillStyle = this.isPlayer ? C.yellow : C.danger;
                    ctx.fillRect(tdx, t.y, 4, 2);
                }
                ctx.restore();
            }
            
            // Draw bullet glow
            ctx.save();
            let glowColor = this.isPlayer ? C.yellow : C.danger;
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 10;
            
            ctx.fillStyle = glowColor;
            if(this.isPlayer) {
                ctx.fillRect(dx, this.y, 8, 4);
            } else {
                ctx.beginPath();
                ctx.arc(dx, this.y, 4, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }
    }

    class Platform {
        constructor(x, y, w, h) {
            this.x = x; this.y = y; this.w = w; this.h = h;
        }
        draw() {
            let dx = this.x - cameraX;
            if (dx > canvas.width || dx + this.w < 0) return;
            ctx.fillStyle = C.pink;
            ctx.fillRect(dx, this.y, this.w, 4);
            ctx.fillStyle = '#150520';
            ctx.fillRect(dx, this.y+4, this.w, this.h-4);
            ctx.fillStyle = '#3a0e4a';
            for(let i=10; i<this.w; i+=30) {
                ctx.fillRect(dx+i, this.y+4, 2, this.h-8);
            }
        }
    }

    class Enemy {
        constructor(x, y, type) {
            this.x = x; this.y = y; this.type = type;
            this.w = 32; this.h = 32;
            this.vx = -1.5;
            this.vy = 0;
            this.startY = y;
            this.active = true;
            this.timer = Math.random() * 100;
            this.hp = 1;
            this.state = 'IDLE'; // For complex behaviors
            
            if (type === 'CHARGER') { this.hp = 2; this.w = 40; }
            if (type === 'PRISM') { this.hp = 2; }
        }

        update() {
            let dx = this.x - cameraX;
            if (dx > 900 || dx < -100) return; // Optimize off-screen
            
            let distToPlayerX = player.x - this.x;
            let distToPlayerY = player.y - this.y;
            let distTotal = Math.sqrt(distToPlayerX*distToPlayerX + distToPlayerY*distToPlayerY);

            // --- AI LOGIC ---
            if (this.type === 'SEEKER') { // ËôöÁ©∫ËøΩË∏™ËÄÖ
                // Slowly float towards player
                this.x += (distToPlayerX > 0 ? 0.8 : -0.8);
                this.y += (distToPlayerY > 0 ? 0.8 : -0.8);
                this.timer++;
            } 
            else if (this.type === 'PRISM') { // ÊïÖÈöúÊ£±Èïú (Â∞ÑÂáªÂ°î)
                // Bob up and down
                this.y = this.startY + Math.sin(this.timer * 0.05) * 10;
                this.timer++;
                // Shoot logic
                if (this.timer % 150 < 1) { // Fire every ~2.5s
                   let dir = distToPlayerX > 0 ? 4 : -4;
                   bullets.push(new Bullet(this.x + 16, this.y + 16, dir, false));
                }
            }
            else if (this.type === 'CHARGER') { // ÈúìËôπÂÜ≤ÈîãËÄÖ
                if (this.state === 'IDLE') {
                    this.x += this.vx;
                    if(frameCount % 120 === 0) this.vx *= -1; // Patrol turn
                    
                    // Spot player? (Same height level, close range)
                    if (Math.abs(distToPlayerY) < 50 && Math.abs(distToPlayerX) < 250) {
                        // Face player
                        if (distToPlayerX > 0 && this.vx < 0) this.vx *= -1;
                        if (distToPlayerX < 0 && this.vx > 0) this.vx *= -1;
                        this.state = 'PREP';
                        this.timer = 30; // 0.5s prep time
                    }
                } else if (this.state === 'PREP') {
                    this.vx = 0;
                    this.timer--;
                    if(this.timer <= 0) {
                        this.state = 'DASH';
                        this.vx = (distToPlayerX > 0 ? 8 : -8); // FAST
                        this.timer = 40; // Dash duration
                    }
                } else if (this.state === 'DASH') {
                    this.x += this.vx;
                    this.timer--;
                    if (this.timer <= 0) {
                        this.state = 'IDLE';
                        this.vx = (this.vx > 0 ? 1.5 : -1.5);
                    }
                }
            }

            // Hitbox checks
            // 1. Being shot
            bullets.forEach(b => {
                if (b.active && b.isPlayer && rectCol(this.x, this.y, this.w, this.h, b.x, b.y, 8, 4)) {
                    this.hp--;
                    b.active = false;
                    createParticles(this.x+this.w/2, this.y+this.h/2, 5, '#fff');
                    if(this.hp <= 0) this.die();
                }
            });

            // 2. Touching player
            if (rectCol(this.x, this.y, this.w, this.h, player.x, player.y, player.w, player.h)) {
                if (player.isDashing) this.die();
                else player.takeDamage(1);
            }
        }

        die() {
            this.active = false;
            score += 200;
            uiScore.innerText = "SCORE: " + score;
            let color = C.pink;
            if(this.type === 'CHARGER') color = C.cyan;
            if(this.type === 'PRISM') color = C.danger;
            createParticles(this.x+this.w/2, this.y+this.h/2, 12, color);
            createShockwave(this.x+this.w/2, this.y+this.h/2);
        }

        draw() {
            let dx = this.x - cameraX;
            // More strict bounds checking
            if (dx > canvas.width + 50 || dx < -50 || this.y > canvas.height + 50 || this.y < -50) return;

            if (this.type === 'SEEKER') {
                // Star/Black hole shape
                ctx.fillStyle = C.purple;
                ctx.beginPath();
                let spikes = 5;
                let outer = 16;
                let inner = 8;
                let cx = dx + 16;
                let cy = this.y + 16;
                // Rotating
                let rot = this.timer * 0.1;
                for(let i=0; i<spikes*2; i++){
                    let r = (i%2===0)?outer:inner;
                    let a = Math.PI*i/spikes + rot;
                    ctx.lineTo(cx + Math.cos(a)*r, cy + Math.sin(a)*r);
                }
                ctx.closePath();
                ctx.fill();
            } 
            else if (this.type === 'PRISM') {
                // Triangle
                ctx.fillStyle = C.danger; // Red
                if(this.timer % 10 < 5) ctx.fillStyle = '#ff9999'; // Flicker
                ctx.beginPath();
                ctx.moveTo(dx + 16, this.y);
                ctx.lineTo(dx + 32, this.y + 32);
                ctx.lineTo(dx, this.y + 32);
                ctx.fill();
                // Eye
                ctx.fillStyle = '#fff';
                ctx.fillRect(dx+12, this.y+16, 8, 8);
            }
            else if (this.type === 'CHARGER') {
                // Rect with spikes
                let color = '#333';
                if(this.state === 'PREP') color = '#fff'; // Flash before attack
                if(this.state === 'DASH') color = C.cyan;
                
                ctx.fillStyle = color;
                ctx.fillRect(dx, this.y + 8, 40, 24);
                // Wheels/Tracks
                ctx.fillStyle = '#111';
                ctx.fillRect(dx+5, this.y+28, 10, 8);
                ctx.fillRect(dx+25, this.y+28, 10, 8);
                // Eye
                ctx.fillStyle = this.state === 'IDLE' ? C.yellow : C.danger;
                ctx.fillRect(dx + (this.vx>0?28:4), this.y + 12, 8, 4);
            }
        }
    }

    class Particle {
        constructor(x, y, color, type = 'DEFAULT') {
            this.x = x; this.y = y; this.color = color;
            this.type = type;
            this.vx = (Math.random()-0.5)*6;
            this.vy = (Math.random()-0.5)*6;
            this.life = 40;
            this.size = Math.random()*4 + 2;
            this.rotation = Math.random()*Math.PI*2;
            this.rotSpeed = (Math.random()-0.5)*0.2;
        }
        update() { 
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
            this.rotation += this.rotSpeed;
            // Add gravity to particles
            this.vy += 0.1;
        }
        draw() {
            let dx = this.x - cameraX;
            // Only draw visible particles
            if(dx < -50 || dx > canvas.width + 50 || this.y < -50 || this.y > canvas.height + 50) return;
            
            ctx.globalAlpha = this.life/40;
            ctx.fillStyle = this.color;
            
            ctx.save();
            ctx.translate(dx, this.y);
            ctx.rotate(this.rotation);
            
            if(this.type === 'DEFAULT') {
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
            } else if(this.type === 'STAR') {
                // Draw star shape
                ctx.beginPath();
                let spikes = 5;
                let outer = this.size;
                let inner = this.size/2;
                for(let i=0; i<spikes*2; i++){
                    let r = (i%2===0)?outer:inner;
                    let a = Math.PI*i/spikes;
                    ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
                }
                ctx.closePath();
                ctx.fill();
            } else if(this.type === 'CIRCLE') {
                ctx.beginPath();
                ctx.arc(0, 0, this.size/2, 0, Math.PI*2);
                ctx.fill();
            }
            
            ctx.restore();
            ctx.globalAlpha = 1;
        }
    }

    let player, platforms, enemies, bullets, particles, shockwaves;

    // --- LEVEL GENERATION ---
    function generateLevel() {
        platforms = [];
        enemies = [];
        bullets = [];
        particles = [];
        shockwaves = [];
        
        // Start ground
        platforms.push(new Platform(-50, 350, 400, 100));
        
        let cx = 350; 
        let cy = 350; 

        // Generate 40 chunks
        for(let i=0; i<40; i++) {
            let type = Math.floor(Math.random() * 5);
            if (i < 2) type = 0; 

            switch(type) {
                case 0: // Flat + Charger
                    platforms.push(new Platform(cx, cy, 350, 100));
                    if(Math.random()>0.3) enemies.push(new Enemy(cx+200, cy-32, 'CHARGER'));
                    cx += 380; 
                    break;
                case 1: // Stairs + Prism (Turret)
                    platforms.push(new Platform(cx, cy, 100, 100));
                    platforms.push(new Platform(cx+120, cy-60, 100, 100));
                    enemies.push(new Enemy(cx+150, cy-120, 'PRISM'));
                    platforms.push(new Platform(cx+240, cy-120, 150, 100));
                    cx += 400;
                    cy -= 120;
                    break;
                case 2: // Pit + Seeker (Flying)
                    platforms.push(new Platform(cx, cy, 100, 100));
                    // Big gap
                    enemies.push(new Enemy(cx+200, cy-50, 'SEEKER'));
                    platforms.push(new Platform(cx+300, cy, 150, 100));
                    cx += 460;
                    break;
                case 3: // High Islands
                    platforms.push(new Platform(cx + 50, cy - 50, 80, 20));
                    enemies.push(new Enemy(cx + 80, cy - 120, 'PRISM'));
                    platforms.push(new Platform(cx + 250, cy, 100, 20));
                    cx += 380;
                    break;
                case 4: // Charger Rush
                    platforms.push(new Platform(cx, cy, 500, 100));
                    enemies.push(new Enemy(cx+100, cy-32, 'CHARGER'));
                    enemies.push(new Enemy(cx+350, cy-32, 'CHARGER'));
                    cx += 520;
                    break;
            }
            if(cy < 150) cy = 150;
            if(cy > 400) cy = 400;
        }
        platforms.push(new Platform(cx, 350, 500, 100));
    }

    function init() {
        player = new Player();
        score = 0;
        cameraX = 0;
        uiScore.innerText = "SCORE: 0";
        updateHealthUI();
        generateLevel();
    }

    function rectCol(x1,y1,w1,h1, x2,y2,w2,h2) {
        return x1 < x2+w2 && x1+w1 > x2 && y1 < y2+h2 && y1+h1 > y2;
    }
    
    function createParticles(x, y, n, c, type = 'DEFAULT') { 
        // Limit maximum particles to 200 to prevent performance issues
        const maxParticles = 200;
        const particlesToAdd = Math.min(n, maxParticles - particles.length);
        for(let i=0;i<particlesToAdd;i++) {
            // Randomly select particle type for more visual variety
            const randType = Math.random() > 0.7 ? (Math.random() > 0.5 ? 'STAR' : 'CIRCLE') : type;
            particles.push(new Particle(x,y,c, randType)); 
        }
    }
    function createShockwave(x, y) { shockwaves.push({x:x, y:y, r:5, a:1}); }
    
    function updateHealthUI() {
        let h = '';
        for(let i=0; i<3; i++) h += i < player.hp ? '‚ù§Ô∏è' : 'üñ§';
        uiHealth.innerHTML = 'HP: ' + h;
    }

    // Loop
    function loop() {
        requestAnimationFrame(loop);
        
        if (gameState === 'PLAYING') {
            frameCount++;
            player.update();
            
            player.grounded = false;
        // Optimized platform collision: only check platforms that are near the player
        platforms.forEach(p => {
            // Only check platforms that are within a reasonable distance from the player
            if (player.x + player.w > p.x - 50 && player.x < p.x + p.w + 50 &&
                player.y + player.h > p.y - 50 && player.y < p.y + p.h + 50) {
                if (player.x + 20 > p.x && player.x + 8 < p.x + p.w &&
                    player.y + player.h >= p.y && player.y + player.h <= p.y + player.vy + 8 &&
                    player.vy >= 0) {
                    player.grounded = true;
                    player.vy = 0;
                    player.y = p.y - player.h;
                    player.jumpCount = 0;
                }
            }
        });

            // Player Bullet collision with enemies logic moved to enemy update
            // Enemy Bullet collision with player - Optimized: only check active enemy bullets near player
            bullets.forEach(b => {
                if(b.active && !b.isPlayer) {
                    // Only check bullets that are near the player
                    if(Math.abs(b.x - player.x) < 100 && Math.abs(b.y - player.y) < 100) {
                        if(rectCol(player.x, player.y, player.w, player.h, b.x, b.y, b.w, b.h)) {
                            player.takeDamage(1);
                            b.active = false;
                        }
                    }
                }
            });

            // Camera
            let targetX = player.x - 300;
            cameraX += (targetX - cameraX) * 0.1;
            if (cameraX < 0) cameraX = 0;

            bullets.forEach(b => b.update());
            enemies.forEach(e => e.update());
            particles.forEach(p => p.update());
            
            bullets = bullets.filter(b => b.active);
            enemies = enemies.filter(e => e.active);
            particles = particles.filter(p => p.life > 0);
        }

        // DRAW
        ctx.fillStyle = C.bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Stars - Optimized: only draw visible stars
        ctx.fillStyle = '#fff';
        for(let i=0; i<60; i++) {
            let sx = (i*97 - cameraX*0.1) % canvas.width;
            if(sx<0) sx+=canvas.width;
            let sy = (i*43) % canvas.height;
            // Only draw stars that are within the canvas bounds
            if(sx >= 0 && sx < canvas.width && sy >= 0 && sy < canvas.height) {
                ctx.globalAlpha = Math.random();
                ctx.fillRect(sx, sy, 2, 2);
            }
        }
        ctx.globalAlpha = 1;

        // Sun
        let sunX = 600;
        let grad = ctx.createLinearGradient(sunX, 150, sunX, 350);
        grad.addColorStop(0, C.yellow);
        grad.addColorStop(1, C.pink);
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(sunX, 250, 70, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = C.bg;
        for(let i=0; i<8; i++) ctx.fillRect(sunX-80, 220+i*12, 160, 3+i); 

        // Entities
        platforms.forEach(p => p.draw());
        enemies.forEach(e => e.draw());
        if (player) player.draw();
        bullets.forEach(b => b.draw());
        particles.forEach(p => p.draw());

        shockwaves.forEach((s, idx) => {
            ctx.strokeStyle = C.cyan;
            ctx.lineWidth = 3;
            ctx.globalAlpha = s.a;
            ctx.beginPath(); ctx.arc(s.x-cameraX, s.y, s.r, 0, Math.PI*2); ctx.stroke();
            s.r += 4; s.a -= 0.08;
            if (s.a <= 0) shockwaves.splice(idx, 1);
            ctx.globalAlpha = 1;
        });
    }

    function startGame() {
        init();
        gameState = 'PLAYING';
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
    }

    function endGame() {
        gameState = 'GAMEOVER';
        finalScoreEl.innerText = "FINAL SCORE: " + score;
        gameOverScreen.classList.remove('hidden');
    }
    
    window.startGame = startGame;
    window.resetGame = startGame;

    function bindTouch(id, key) {
        const el = document.getElementById(id);
        if(!el) return;
        const h = (e) => { e.preventDefault(); keys[key] = true; el.classList.add('active'); };
        const r = (e) => { e.preventDefault(); keys[key] = false; el.classList.remove('active'); };
        el.addEventListener('touchstart', h);
        el.addEventListener('touchend', r);
        el.addEventListener('mousedown', h);
        el.addEventListener('mouseup', r);
    }

    bindTouch('btn-left', 'left');
    bindTouch('btn-right', 'right');
    bindTouch('btn-jump', 'up');
    bindTouch('btn-shoot', 'shoot');
    bindTouch('btn-dash', 'dash');

    window.addEventListener('keydown', e => {
        if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
        if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.up = true;
        if (e.key === 'j' || e.key === 'z') keys.shoot = true;
        if (e.key === 'k' || e.key === 'Shift') keys.dash = true;
    });
    window.addEventListener('keyup', e => {
        if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
        if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.up = false;
        if (e.key === 'j' || e.key === 'z') keys.shoot = false;
        if (e.key === 'k' || e.key === 'Shift') keys.dash = false;
    });

    init();
    loop();

})();
</script>
</body>
</html>